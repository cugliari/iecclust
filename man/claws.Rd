% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{claws}
\alias{claws}
\title{CLAWS: CLustering with wAvelets and Wer distanceS}
\usage{
claws(series, K1, K2, nb_series_per_chunk, nb_items_clust = 5 * K1,
  algoClust1 = function(data, K) cluster::pam(t(data), K, diss = FALSE,
  pamonce = 1)$id.med, algoClust2 = function(dists, K) cluster::pam(dists, K,
  diss = TRUE, pamonce = 1)$id.med, wav_filt = "Coiflets:1",
  contrib_type = "absolute", WER = "end", smooth_lvl = 3, nvoice = 4,
  random = TRUE, ntasks = 1, ncores_tasks = 1, ncores_clust = 3,
  sep = ",", nbytes = 4, endian = .Platform$endian, verbose = FALSE)
}
\arguments{
\item{series}{Access to the N (time-)series, which can be of one of the four
following types:
\itemize{
  \item [big.]matrix: each column contains the (time-ordered) values of one
    time-serie
  \item connection: any R connection object providing lines as described above
  \item character: name of a CSV file containing series in rows (no header)
  \item function: a custom way to retrieve the curves; it has only one argument:
    the indices of the series to be retrieved. See SQLite example
}}

\item{K1}{Number of clusters to be found after stage 1 (K1 << N)}

\item{K2}{Number of clusters to be found after stage 2 (K2 << K1)}

\item{nb_series_per_chunk}{Number of series to retrieve in one batch}

\item{nb_items_clust}{Number of items in 1st clustering algorithm input}

\item{algoClust1}{Clustering algorithm for stage 1. A function which takes (data, K)
as argument where data is a matrix in columns and K the desired number of clusters,
and outputs K medoids ranks. Default: PAM.}

\item{algoClust2}{Clustering algorithm for stage 2. A function which takes (dists, K)
as argument where dists is a matrix of distances and K the desired number of
clusters, and outputs K medoids ranks. Default: PAM.}

\item{wav_filt}{Wavelet transform filter, as a string "Family:FilterNumber"; see
?wavethresh::wd}

\item{contrib_type}{Type of contribution: "relative", "logit" or "absolute" (any
prefix)}

\item{WER}{"end" to apply stage 2 after stage 1 has fully iterated, or "mix" to apply
stage 2 at the end of each task}

\item{smooth_lvl}{Smoothing level: odd integer, 1 == no smoothing.}

\item{nvoice}{Number of voices within each octave for CWT computations}

\item{random}{TRUE (default) for random chunks repartition}

\item{ntasks}{Number of tasks (parallel iterations to obtain K1 [if WER=="end"]
or K2 [if WER=="mix"] medoids); default: 1.\cr
Note: ntasks << N (number of series), so that N is "roughly divisible" by ntasks}

\item{ncores_tasks}{Number of parallel tasks ('1' == sequential tasks)}

\item{ncores_clust}{Number of parallel clusterings in one task}

\item{sep}{Separator in CSV input file (if any provided)}

\item{nbytes}{4 or 8 bytes to (de)serialize a floating-point number}

\item{endian}{Endianness for (de)serialization: "little" or "big"}

\item{verbose}{FALSE: nothing printed; TRUE: some execution traces}
}
\value{
A list:
\itemize{
  \item medoids: matrix of the final K2 medoids curves
  \item ranks: corresponding indices in the dataset
  \item synchrones: sum of series within each final group
}
}
\description{
Cluster electricity power curves (or any series of similar nature) by applying a
two stage procedure in parallel (see details).
Input series must be sampled on the same time grid, no missing values.
}
\details{
Summary of the function execution flow:
\enumerate{
  \item Compute and serialize all contributions, obtained through discrete wavelet
    decomposition (see Antoniadis & al. [2013])
  \item Divide series into \code{ntasks} groups to process in parallel. In each task:
  \enumerate{
    \item iterate the first clustering algorithm on its aggregated outputs,
      on inputs of size \code{nb_items_clust}\cr
        -> K1 medoids indices
    \item optionally, if WER=="mix":\cr
      a. compute WER distances (K1xK1) between medoids\cr
      b. apply the 2nd clustering algorithm\cr
         -> K2 medoids indices
  }
  \item Launch a final task on the aggregated outputs of all previous tasks:
    ntasks*K1 if WER=="end", ntasks*K2 otherwise
  \item Compute synchrones (sum of series within each final group)
}

The main argument -- \code{series} -- has a quite misleading name, since it can be
either a [big.]matrix, a CSV file, a connection or a user function to retrieve series.
When \code{series} is given as a function it must take a single argument,
'indices': integer vector equal to the indices of the curves to retrieve;
see SQLite example.
WARNING: the return value must be a matrix (in columns), or NULL if no matches.

Note: Since we don't make assumptions on initial data, there is a possibility that
even when serialized, contributions do not fit in RAM. For example,
30e6 series of length 100,000 would lead to a +4Go contribution matrix. Therefore,
it's safer to place these in (binary) files; that's what we do.
}
\examples{
\dontrun{
# WER distances computations are too long for CRAN (for now)
# Note: on this small example, sequential run is faster

# Random series around cos(x,2x,3x)/sin(x,2x,3x)
x <- seq(0,50,0.05)
L <- length(x) #1001
ref_series <- matrix( c(cos(x),cos(2*x),cos(3*x),sin(x),sin(2*x),sin(3*x)), ncol=6 )
library(wmtsa)
series <- do.call( cbind, lapply( 1:6, function(i)
  do.call(cbind, wmtsa::wavBootstrap(ref_series[,i], n.realization=40)) ) )
# Mix series so that all groups are evenly spread
permut <- (0:239)\%\%6 * 40 + (0:239)\%/\%6 + 1
series = series[,permut]
#dim(series) #c(240,1001)
res_ascii <- claws(series, K1=30, K2=6, nb_series_per_chunk=500,
  nb_items_clust=100, random=FALSE, verbose=TRUE, ncores_clust=1)

# Same example, from CSV file
csv_file <- tempfile(pattern="epclust_series.csv_")
write.table(t(series), csv_file, sep=",", row.names=FALSE, col.names=FALSE)
res_csv <- claws(csv_file, 30, 6, 500, 100, random=FALSE, ncores_clust=1)

# Same example, from binary file
bin_file <- tempfile(pattern="epclust_series.bin_")
nbytes <- 8
endian <- "little"
binarize(csv_file, bin_file, 500, ",", nbytes, endian)
getSeries <- function(indices) getDataInFile(indices, bin_file, nbytes, endian)
res_bin <- claws(getSeries, 30, 6, 500, 100, random=FALSE, ncores_clust=1)
unlink(csv_file)
unlink(bin_file)

# Same example, from SQLite database
library(DBI)
series_db <- dbConnect(RSQLite::SQLite(), "file::memory:")
# Prepare data.frame in DB-format
n <- ncol(series)
times_values <- data.frame(
  id = rep(1:n,each=L),
  time = rep( as.POSIXct(1800*(1:L),"GMT",origin="2001-01-01"), n ),
  value = as.double(series) )
dbWriteTable(series_db, "times_values", times_values)
# Fill associative array, map index to identifier
indexToID_inDB <- as.character(
  dbGetQuery(series_db, 'SELECT DISTINCT id FROM times_values')[,"id"] )
serie_length <- as.integer( dbGetQuery(series_db,
  paste("SELECT COUNT(*) FROM times_values WHERE id == ",indexToID_inDB[1],sep="")) )
getSeries <- function(indices) {
  indices = indices[ indices <= length(indexToID_inDB) ]
  if (length(indices) == 0)
    return (NULL)
  request <- "SELECT id,value FROM times_values WHERE id in ("
  for (i in seq_along(indices)) {
    request <- paste(request, indexToID_inDB[ indices[i] ],  sep="")
    if (i < length(indices))
      request <- paste(request, ",", sep="")
  }
  request <- paste(request, ")", sep="")
  df_series <- dbGetQuery(series_db, request)
  matrix(df_series[,"value"], nrow=serie_length)
}
res_db <- claws(getSeries, 30, 6, 500, 100, random=FALSE, ncores_clust=1)
dbDisconnect(series_db)

# All results should be equal:
all(res_ascii$ranks == res_csv$ranks
  & res_ascii$ranks == res_bin$ranks
  & res_ascii$ranks == res_db$ranks)
}
}
\references{
Clustering functional data using Wavelets [2013];
  A. Antoniadis, X. Brossat, J. Cugliari & J.-M. Poggi.
  Inter. J. of Wavelets, Multiresolution and Information Procesing,
  vol. 11, No 1, pp.1-30. doi:10.1142/S0219691313500033
}
